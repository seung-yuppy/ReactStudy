소프트웨어 품질
 - 소프트웨어의 유용성을 얻기위해 갖춰야하는 특성들의 집합
 - 사용자의 요구사항이나 만족도를 얼마나 충족시키는가의 대한 지표

좋은 소프트웨어란?
 - 버그는 전혀 없지만 고객이 사용하기에 좋지않은(재미없는) s/w
  vs
 - 버그가 불편하지 않을정도로는 있지만 고객이 사용하기 재미있거나 유익한 s/w

당연히 제품을 출시하려면 버그는 가급적 없어야함. -> 그것보다 중요한건 사용자가 편한가?
버그없는 제품을 만드는것도 당연하지만 최우선순위는 사용자의 니즈.

컴퓨터공학의 학습
추후의 학습방향

1. 순수 공학을 위한 연구의 학습(공부) -> 기본개념들을 하나하나 깊이 파고드는 형식
2. 현업(실무)에 적용하기 위한 작업 효율을 개선하기위한 혹은 적응하기위한 학습방향
    -> 얇고 넓게 보면서 필요한 내용들의 깊이를 챙겨가는 방식,.

요구사항의 만족중 하나가 사용에 불편함이 없어야한다.
 -> 사람마다 기준이 다르다보니 모든 고객을 100% 만족시킬수는 없음.
 -> 품질의 문제는 꾸준히 개선해야하지만 최소한의 퀄리티는 당연히 지켜야함.
 -> 생각보다 충성고객들이 확보되면 어느정도의 버그는 눈감아 주려 노력하지만
    정도가 심하면 이탈고객이 점점 많아짐
 -> 좋은 품질을 보장받기위해서는 설계도 중요하지만 그만큼 테스트도 중요.

테스트 원리.
1. 테스팅은 결함이 존재함을 밝히는것.(설령 테스트시 결함/문제가 발견되지 않아도 막상 서비스를 오픈했을때
   충분히 에러가 발생할수 있음을 기억해야함.)
2. 완벽한 테스팅은 불가능. 테스팅전에는 우선순위에 따른 테스팅이 필요
3. 테스팅은 빨리할수록 좋긴함.(TDD / 결함을 조기에 발견하기위해)
4. 최신기술이라고 무조건 좋은거 아님. -> 프로젝트에 맞게 다른부분과 상호작용이 어떻게 되는가를
   고려하지않으면 새로운 결함을 발생시킬수 있고 운영상 장애를 초래.
5. (제일중요) 동일한 테스트 케이스로 동일한 테스트를 반복적으로 수행하면 새로운 결함을 찾아내기 어려움
    - 신입 개발자들이 놓치는 부분
      1. 테스트할때 새로운 에러가 나오는것이 두려움(테스트때 에러나는게 천만다행임)
      2. 에러 숨기고 가지마세요......(조금 혼나더라도 꼭 해결하고...)
         (혼나기 vs 입사 6개월만에 회사 망해서 직장 잃기.)
   테스트케이스는 다다익선. 또한 테스트케이스는 지속적으로 보완, 개선의 필요성이 있음.
    -> 다른 시각과 기법으로 테스트하는것또한 매우 중요(개발자 동료들 끼리 교차로 테스트하기.)
  
6. 많은 결함을 수정하는것이 고객의 만족도와 비례하진 않음.
    -> 품질 보증이 시장의 성공을 100% 보장하지 않음.
결론 : 테스트 중요하지만 역시나 s/w는 사용자가 쓰기 좋아야함.


sw개발 생명주기상 테스트
1. 폭포수 모델
   - 폭포의 흐름같이 순차적으로 진행.
   - 기존 폭포수모델은 실제 개발환경과는 괴리감이 있어서
     변형된 폭포수 모델들이 등장.
   - 테스트 단계에서 문제점이 발견되면 요구사항 분석 단계부터 다시 전체 개발 프로세스를 진행.
  
2. V 모델
   - TDD와 조금 비슷.

3. 소프트웨어 검증
   - 최종산출물이 아닌 중간 단계 산출물이 정의된 요구사항을 만족하는지 평가하는 과정
   - 요구사항정의서, 설계서 , 테스트케이스

테스트 수명주기와 프로세스(이미지 폴더의 이미지들을 참조(파일명은 같음))

소프트웨어 테스트 종류
1. 동적테스트 : 테스트 대상 요소를 직접 다루어서 테스트해보는 방식
    - 구성된 화면 기능들 직접 일일히 눌러보면서 테스트(가장 보편적인 테스트방식)
    - 게임분야에서 활용을 많이하는편
    - 웹 분야에서는 게임분야처럼 전문테스터를 소집하기도 하지만 일부기능들만 오픈한후
      버그가 발견되는 즉시 해결하는 방법도 채용.
2. 정적테스트 : 툴을 이용하여 문법규칙이나 오류를 찾는등의 잠재적 코드 오류 개선.
3. 스크립티드 테스트 : 스크립트가 만들어져있고 그대로 따라가는테스트
4. 탐색 테스트 : 경험, 직관을 통한 테스트케이스 작성후 수행.
    - 개발자가 다른 프로젝트등을 통해 얻은 경험을 기반하여 에러가 날 가능성이 높은
      부분에 대해 테스트 비중을 높이거나 수행해보는 개념
5. 회귀테스트(리그레션 테스트) : 보고서대로 작업이 제대로 수행되었는가를 확인하는 작업.
6. 스모크 테스트 : 테스트 할만한 수준인지 체크하는 테스트
    - 전반적으로 테스트를 할 필요가 있는가를 확인
      -> 기능구현이 아직 안됐는데 굳이 테스트를 할 필요가 있는가?
7. 보안테스트 : 보안상 문제가 있는가 XSS등의 공격에 대비를 해두었는가 등을 확인.
    - 시큐어 코딩 잘 했는가 확인.
8. 성능테스트 : 서버의 응답시간이나 리소스 활용여부등을 체크하는 테스트
9. 신뢰성 테스트 : 신뢰성이라고 함은 끊임없는 서비스 제공이 최우선(웹 개발)
    -> 꾸준하게 서비스를 제공하는것이 기본.
    -> 여태껏 얘기했던 내용들은 사실 단발적으로 일어나는 일들에 대한 테스트지만
       동작 후 일어나는 일들이나 혹은 동작을 중단해야만 변경이 가능한 경우도 있음.
10. 블랙박스 테스트 : 소프트웨어가 수행할 특정 기능을 알기위해 각 기능이 완전히 작동되는것을
                     입증하는 테스트. (기능테스트) / 입출력값만 확인함.
    종류
    동치분할검사(Equavialence Partitioning) : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는법
    원인-효과 그래프검사(Cause and Effect Graphing) : 입력 데이터간의 관계와 출력에 영향을 미치는
                                                     상황을 체계적으로 분석.
    오류예측검사 (Error Forecase) : 과거의 경험이나 감각으로 테스트하는 기법(보충적 검사 기법)
    비교검사 (Comparison Testing) : 동일한 테스트 자료를 여러 버전의 프로그램에 입력하여
                                    동일한 결과가 출력되는 테스트 하는 기법.
    경계값 분석(Boundary Value Analysis) : 입력 조건 경계값에서 오류 발생확률이
                                          크다는 것을 활용하여 경계값을 테스트 케이스로 선정하여 검사.

11. 화이트박스 테스트 : 모듈의 원시코드를 오픈시킨 상태에서 코드의 논리적인 모든 경로를 테스트하는 방법
     -> 모듈안의 작동을 직접관찰할수 있다는 특징이 있음.
     -> 논리적인 경로를 점검하는것이 핵심. 프로그램의 제어 구조에따라 선택, 반복등의 부분들을 수행.
     -> 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트에 해당.

화이트박스 테스트 종류
1. 기초 경로 검사(Basic Path Testing) : 수행 가능한 모든 경로
    -> 경로 경우의 수를 결정한 후에 각 경로에 대한 테스트 사례를 생성.
2. 제어 구조 검사
    - 조건 검사 : 프로그램 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법
    - 루프 검사 : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
    - 데이터 흐름 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰
                        실시하는 테스트케이스 설계 기법.

그렇다면 화이트박스 테스트가 유용한 순간과
블랙박스 테스트가 유용한 순간을 구분
 - 화이트박스 : 로직(프로젝트) 흐름의 큰 줄기. / 문장, 분기, 조건
 - 블랙박스 : 성능, 인터페이스, 자료구조, 부정확한 코드, 유효성검사(에러(예외)처리)

-------------------------------------------------------------------------------------

소프트웨어 오류의 밀집성
 - 소프트웨어가 자주 오류나는 부분은 오류나는 수만큼 오류 존재 가능성이 비례함.

이론상으로의 테스트 시나리오는 사실 완벽. 하지만 테스트 시나리오는 한계가 명백하게 존재
 (테스터의 한계)
1. 경력이 전혀 없는 웹개발은 해본적도 없는 사람 (프로그램이 어떻게 돌아가는지 전혀 모름)
2. 경력 3~5년의 웹 개발 경험이 있는 사람 - 다른 회사 제품 테스트시 제일 적합.(감리)
3. 경력 10년 이상의 웹 개발 경험이 있는 사람.(로직에 집중을 하는 성향이 강함.)
다음중 테스터로 가장 어울리는(적합한) 사람은?
 - 정답 : 상황따라 다름.(상황의 기준 : 화이트박스 vs 블랙박스.)
   결론부터 얘기하면 시간과 금액이 허락된다면 모두가 참여하는게 제일 좋음.
   -> 이상적으로는 이 방법이 가장좋음 하지만 완벽한 테스트는 불가능하다는점.(구글, MS건 마찬가지)
      (무한한 테스트 또한 비현실적)
   -> 최대한 시간과 비용을 고려하여 효율적으로 테스트 하되 발견 못한 부분들은 즉각즉각 처리.
   -> 결론은 사용자 역량이라는거...

소프트웨어가 가장 오류가 많이 발생하는 경우는 다음중 무엇일지 고민해보고 이유를 작성
1. 요구사항의 오류 - 클라이언트 문제일 가능성이 90%이상.(의사소통 문제일 가능성) / 56%
   - 클라이언트의 의도대로 전달이 안되는 경우도 있음 but 개발자가 의도적으로 빼먹는 경우도 있음.
   - 클라이언트들은 개발자들이 1~2일이면 다 할거라 예상.
     (의사소통상의 문제점이 굉장히 많이 발생.)
   - 클라이언트들이 추가로 요청하는 경우가 자주발생 -> 요구사항에 없는 기능을 추가하는 경우도 존재.
2. 설계상의 오류 - 의사소통의 문제 - 25%
3. 구현(코딩)상의 오류 - 10%
4. 그 외. - 나머지 퍼센티지
   - 요구사항 미준수, 코딩 표준을 지키지 않는 경우, 모바일 개발에서는 OS 버전상 억까를 당하는 경우가있음.

에러, 결함, 오작동
 - 에러 : 인간의 실수
 - 결함 : 에러 + 누락, 오입력
 - 오작동 : 개발자가 원치 않은 작동.
   (당장은 문제가 없을수 있다는게 골때림.)
     -> 오작동이 지속될 경우는 장기적으로 성능상의 문제가 발생하거나
        혹은 추후 에러가 발생할 여지점이 남아있음.

소프트웨어 테스트 7원칙
1. 가장 좋은 테스터는 프로그램을 개발한 팀과는 무관한 사람들이 진행해야함.
2. 테스트의 마무리작업은 능력이 좋은사람이 하는게 좋음.
3. 자만하지말것.(오류가 없을거라는 생각은 무조건 버릴것)
   -> 애초에 테스트는 오류를 발견하기위해 진행하는것.
4. 예상치 못한경우, 타당하지 않은 경우는?
   -> 당연히 테스트 진행 필요 (실제로 사용하는 유저들은 제품에 대한 이해도가 높을까요?)
      유저들은 대부분 우리 소프트웨어에 대한 이해도가 높지 않다라는점.
   -> 이럴경우를 대비해서 많은 부분들을 예측하여 테스트할 필요가 있음.
5. 오류가 남아있을 확률은 이미 발견된 오류의 수에 비례.
   -> 오류가 자주 발생한곳에는 다시 오류가 생길가능성이 높음.
   -> 에러 고치면서 이전 코드들 반드시 백업.
6. 테스트 케이스의 체계적 관리 필요.(쉽지않음)
7. 테스트 결과 철저히 점검.(지속적으로 관리 잘해줄것.)